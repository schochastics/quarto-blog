{
  "hash": "9c62f3ba892118ef63f348da1dfcafef",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Working with R data.frames in Rust\"\nauthor:\n  - name: David Schoch\n    orcid: 0000-0003-2952-4812\ndate: 2024-10-29\ncategories: [R, rust]\n---\n\n\n\nI have blogged about using Rust in R twice before. Once about a [phone number parser](https://blog.schochastics.net/posts/2024-02-23_parsing-phone-numbers-with-rust-and-r/) called [dialrs](https://github.com/schochastics/dialrs) and once about a [datetime parser](https://blog.schochastics.net/posts/2024-02-27_chronos-fast-general-purpose-datetime-converter/) called [timeless](https://github.com/schochastics/timeless). There is a actually third post about [the archival of timeless](https://blog.schochastics.net/posts/2024-09-25_tales-from-os-dev-001) on CRAN due to \nsome issues with the Rust policies. Both packages are really rudimentary in terms of the included Rust code. After all, I am still a beginner and quite happy if I get anything to run at all. So this should also serve as a disclaimer for this post. Take any Rust code you will see here with a grain of salt. Just because it works, doesn't mean it is the best way (or even correct way).\n\n## General remarks on Rust in R\n\nhttps://teuder.github.io/rcpp4everyone_en/\nhttps://gallery.rcpp.org/\n\n## Returning vectors in Rust functions\n\nWhat I meant with \"rudimentary\" above is that both packages only wrap one or two [crates](https://crates.io/)  and the most complex return values are vectors of strings, 'Vec<String>' in Rust terminology.\n\nHere is for example a function that parses international phone numbers from `dialrs`\n```rust\nfn parse_phone_rs_international(phone: Vec<String>, country: &str) -> Vec<String> {\n    let region = phonenumber::country::Id::from_str(country).ok();\n    phone\n        .into_iter()\n        .map(\n            |input| match phonenumber::parse(region, strip_hyphens(&input)) {\n                Ok(number) => number.format().mode(Mode::International).to_string(),\n                Err(_e) => String::new(),\n            },\n        )\n        .collect()\n}\n```\nand here is a function from `timeless` which tries to parse datetime from a string\n```rust\nfn parse_guess_rs(times: Vec<String>) -> Vec<String> {\n    times\n        .iter()\n        .map(|input| match input.parse::<DateTimeUtc>() {\n            Ok(value) => value\n                .0\n                .format(\"%Y-%m-%d %H:%M:%S\")\n                .to_string(),\n            Err(_e) => \"not found\".to_string(),\n        })\n        .collect()\n}\n```\n\n\nIn both cases the input and output are just character vectors. [rextendr](https://github.com/extendr/rextendr) can deal with these return type (vectors) without issues. But what if we want to move beyond simple vectors?\n\n## Returning matrices in Rust functions\n\nWith my limited experience, I thought that something like `Vec<Vec<String>>` could be the right structure to return something \"2 dimensional\". While it actually does represent a 2D array-like structure, it does not enforce a strict rectangular shape. So each inner vector can have different lengths. So somewhat comparable to a List in R where all entries have to have the same type. So lets try to assemble a matrix-like list thing.\nBefore showing the Rust code, here is the equivalent in R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreate_matrix <- function(n, m) {\n  lapply(seq_len(n), function(r) (1:m) + (r - 1) * m)\n}\ncreate_matrix(n = 3, m = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1 2 3 4\n\n[[2]]\n[1] 5 6 7 8\n\n[[3]]\n[1]  9 10 11 12\n```\n\n\n:::\n:::\n\n\n\nNow this is what it would look like in Rust.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrextendr::rust_function(\n  \"fn create_matrix(n: usize, m: usize) -> Vec<Vec<usize>> {\n    (0..n).map(|i| {\n        (0..m).map(|j| i * m + j + 1).collect()\n    }).collect()\n  }\"\n)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `invoke_cargo()`:\n! Rust code could not be compiled successfully. Aborting.\n✖ error[E0277]: the trait bound `extendr_api::Robj: From<Vec<Vec<usize>>>` is not satisfied\n --> src/lib.rs:2:1\n  |\n2 | #[extendr]\n  | ^^^^^^^^^^ the trait `From<Vec<Vec<usize>>>` is not implemented for `extendr_api::Robj`\n  |\n  = help: the following other types implement trait `From<T>`:\n            `extendr_api::Robj` implements `From<&Altrep>`\n            `extendr_api::Robj` implements `From<&Primitive>`\n            `extendr_api::Robj` implements `From<&Vec<T>>`\n            `extendr_api::Robj` implements `From<&[T; N]>`\n            `extendr_api::Robj` implements `From<&[T]>`\n            `extendr_api::Robj` implements `From<&extendr_api::Complexes>`\n            `extendr_api::Robj` implements `From<&extendr_api::Doubles>`\n            `extendr_api::Robj` implements `From<&extendr_api::Environment>`\n          and 63 others\n  = note: this error originates in the attribute macro `extendr` (in Nightly builds, run with -Z macro-backtrace for more info)\n```\n\n\n:::\n:::\n\n\n\nOk so this doesnt work. There is a lot going on in that error message. For now, we focus on this part:\n```\nthe trait `From<Vec<Vec<usize>>>` is not implemented for `extendr_api::Robj`\n``` \n\nWhat it tries to tell us is that we cannot have `<Vec<Vec<usize>>` as a return value because it is supported by the API that connects R and Rust.\n\nLet us try it with the [nalgebra](https://crates.io/crates/nalgebra) crate which allows us to actually build matrices.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncode <- r\"(\n  use nalgebra::DMatrix;\n\n  #[extendr]\n  fn create_matrix(n: usize, m: usize) -> DMatrix<usize> {\n      DMatrix::from_iterator(n, m, (1..=n * m))\n  }\n)\"\n\n\nrextendr::rust_source(\n  code = code,\n  dependencies = list(`nalgebra` = \"0.33\")\n)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `invoke_cargo()`:\n! Rust code could not be compiled successfully. Aborting.\n✖ error[E0277]: the trait bound `Matrix<usize, Dyn, Dyn, VecStorage<usize, Dyn, Dyn>>: ToVectorValue` is not satisfied\n --> src/lib.rs:5:3\n  |\n5 |   #[extendr]\n  |   ^^^^^^^^^^ the trait `ToVectorValue` is not implemented for `Matrix<usize, Dyn, Dyn, VecStorage<usize, Dyn, Dyn>>`\n  |\n  = help: the following other types implement trait `ToVectorValue`:\n            &&str\n            &(f64, f64)\n            &Rbool\n            &Rcplx\n            &Rfloat\n            &Rint\n            &String\n            &bool\n          and 45 others\n  = note: required for `extendr_api::Robj` to implement `From<Matrix<usize, Dyn, Dyn, VecStorage<usize, Dyn, Dyn>>>`\n  = note: this error originates in the attribute macro `extendr` (in Nightly builds, run with -Z macro-backtrace for more info)\n```\n\n\n:::\n:::\n\n\n\nThis looks pretty much like the same error. Something is not implemented that we need to transfer the Matrix to R. Maybe it is time to RTFM to understand what is going on\n\n## The R/Rust interface\n \nOur situation is actually well descriped in the (work in progress) [user guide](https://extendr.github.io/user-guide/) of the crate `extendr-api` in the section about [macros](https://extendr.github.io/user-guide/type-mapping/extendr-macro.html). In order for an item to be returned to R from a function written in Rust, the return value must be able to be turned into an R object. This makes a lot of sense. Obviously, if R gets something that it doesn't understand, it cannot deal with it. But there is a way to MAKE R understand, even if it does not understand the original result.\n\nThe `ToVectorValue` trait is what is used to convert Rust items into R objects. We have seen this pop up in the last error message we got from the `nalgebra` crate. The trait is implemented on a number of standard Rust types such as i32, f64, usize, String and many more. So if any of these are returned, R knows what to do. \n\nYou might ask yourself: \"What the hell is a trait?\". That is a very good question. It has something to do with types. Say you want to write a simple sum\n\n```rust\nfn add(x: i32, y: i32) -> i32 {\n    x + y\n}\n```\n\nThis is fine, but we would have to create a function for every single number type there is (u32, f64 etc.). How can we abstract this? The answer is traits. \n\n```rust\nuse std::ops::Add;\n\nfn add<T: Add>(x: T, y: T) -> T {\n    x + y\n}\n```\n\nThe trait `Add` implements addition for a large variety of types (see [here](https://doc.rust-lang.org/nightly/std/ops/trait.Add.html#implementors)). But even if the type you need is not supported, you can implement it yourself with an `impl` block. \n\n```rust\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Add for Point {\n    type Output = Self;\n\n    fn add(self, other: Self) -> Self {\n        Self {\n            x: self.x + other.x,\n            y: self.y + other.y,\n        }\n    }\n}\n```\n\nIn this example we define a structure that is a point with two `i32` coordinates and the `impl` block tells Rust how to use the Add trait for this structure. But as you might realize, we have again only defined the structure for one specific type, `i32`. We can extend it in a very similar way as above.\n\n```rust\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n\nimpl<T: Add<Output = T>> Add for Point<T> {\n    type Output = Self;\n\n    fn add(self, other: Self) -> Self::Output {\n        Self {\n            x: self.x + other.x,\n            y: self.y + other.y,\n        }\n    }\n}\n```\n\nIn `extendr`, the struct `Robj` is a catch all for any type of R object. \n\n\n## Returning data.frames in Rust functions\n\nData frames in R are essential because they provide a structured, table-like format for handling heterogeneous data, seamlessly integrating numeric, character, and factor variables within a single dataset. Their flexibility, built-in functions, and compatibility with R’s data manipulation packages (like the `tidyverse`) make them the go-to structure for efficient data analysis and visualization. \n\nGiven their importance, it is obvious that we also want to work with them in Rust. For general data analytic tasks, there is [polars](https://docs.rs/polars/latest/polars/). Polars is extremely powerful and we can already benefit from that in with [r-polars](https://github.com/pola-rs/r-polars). The syntax might be a bit strange for newcomers, but there \nis [tidypolars](https://github.com/etiennebacher/tidypolars) which promisses to provide a polars backend for the `tidyverse`. What this essentially means is that you can keep your `tidyverse` code while using polars in the background. That is a pretty awesome prospect.\n\n ",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}