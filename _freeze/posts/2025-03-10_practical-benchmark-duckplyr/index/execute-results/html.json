{
  "hash": "83bf2fb4cf42dec756e1253d327e4300",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"A practical benchmark of duckplyr\"\nauthor:\n- name: David Schoch\n  orcid: 0000-0003-2952-4812\ndate: '2025-03-10'\ncategories:\n- R\n- data analysis\n---\n\n\n\nBenchmarking is hard and it is really tricky to find the right type of data and settings to make a truly fair comparison of different approaches to achieve the same thing. \nI have seen enough heated discussions on social media. \nI am still curious how the shiny new version of [duckplyr](https://github.com/tidyverse/duckplyr) compares to other established data\nwrangling libraries in R. However, I will not attempt to do any rigorous performance analysis. \nThis post is only driven by a practical interest of mine: I need fast summarization and fast joins. \nSo the results may not paint the full picture.\n\n## Libraries\n\nI will just do a lazy introduction of all packages and simply paste short paragraphs from GitHub. If you are new to a package, please checkout the respective repository for more help.\n\n### dplyr  \n[dplyr](https://dplyr.tidyverse.org/) is a grammar of data manipulation, providing a consistent set of verbs that help you solve the most common data manipulation challenges\n\n### duckplyr\nThe [duckplyr](https://duckplyr.tidyverse.org/) package will run all of your existing dplyr code with identical results, using [DuckDB](https://duckdb.org/) where possible to compute the results faster. In addition, you can analyze larger-than-memory datasets straight from files on your disk or from the web.\n\n### data.table\n[data.table](https://github.com/Rdatatable/data.table) provides a high-performance version of base R's data.frame with syntax and feature enhancements for ease of use, convenience and programming speed.\n\n### polars\nThe [polars](https://github.com/pola-rs/r-polars) package for R gives users access to a lightning fast Data Frame library written in [Rust](https://www.pola.rs/).\n\n### tidypolars\n[tidypolars](https://github.com/etiennebacher/tidypolars/) provides a polars backend for the tidyverse. \nThe aim of tidypolars is to enable users to keep their existing tidyverse code while using polars in the background to benefit \nfrom large performance gains. \n\n### collapse\n[collapse](https://github.com/SebKrantz/collapse) is a large C/C++-based package for data transformation and statistical computing in R. \nIt aims to:\n\n- Facilitate complex data transformation, exploration and computing tasks in R.\n- Help make R code fast, flexible, parsimonious and programmer friendly.\n\n### Personal thoughts\n\nI find the concepts of `duckplyr` and `tidypolars` truly amazing. \nYou essentially get performance upgrades for free when you have been working with `dplyr`. \nSo there is (almost) no refactoring needed. \n\n`data.table` was my first shift away from the tidyverse around 5 years ago. \nMy football side project had grown to a size that made working with `dplyr` slightly annoying \nbecause certain operations just took to long. I did a major refactoring of the code base and since then, \nthe project runs on `data.table`. Working with its syntax though can be a challenge and might not be intuitive for \neverybody (I too have to look up syntax all the time). \n\nI do like Rust and I have been experimenting with it a lot, \nmostly to get it to work with [R](https://blog.schochastics.net/#category=Rust). \nSo it may come as no surprise that I do like `polars`. Similar to `data.table`, its syntax might not be as straightforward, \nbut thats what we now have `tidypolars` for. \n\nWhile I never really used `collapse`, I do have mad respect for its main developer, Sebastian Krantz. \nI'd encourage you to read his blog posts on [collapse 2.0](https://sebkrantz.github.io/Rblog/2023/10/17/releasing-collapse-2-0-blazing-fast-joins-reshaping-and-enhanced-r/) and on \n[the state of the fastverse](https://sebkrantz.github.io/Rblog/2023/04/12/collapse-and-the-fastverse-reflecting-the-past-present-and-future/).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(duckplyr)\nlibrary(data.table)\nlibrary(polars)\nlibrary(tidypolars)\nlibrary(collapse)\n\npackageVersion(\"dplyr\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] '1.1.4'\n```\n\n\n:::\n\n```{.r .cell-code}\npackageVersion(\"duckplyr\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] '1.0.1'\n```\n\n\n:::\n\n```{.r .cell-code}\npackageVersion(\"data.table\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] '1.16.4'\n```\n\n\n:::\n\n```{.r .cell-code}\npackageVersion(\"polars\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] '0.22.1'\n```\n\n\n:::\n\n```{.r .cell-code}\npackageVersion(\"tidypolars\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] '0.13.0'\n```\n\n\n:::\n\n```{.r .cell-code}\npackageVersion(\"collapse\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] '2.1.0'\n```\n\n\n:::\n:::\n\n\n\n## Data\n\nThe data I am using is a set of ~1 million football game results around the world. \nYou can find the data on [GitHub](https://github.com/schochastics/football-data) \n(This data set is part of my [worldclubratings](http://worldclubratings.net) side project.).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- nanoparquet::read_parquet(\"games.parquet\")\nstr(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nClasses 'tbl' and 'data.frame':\t1237935 obs. of  17 variables:\n $ home          : chr  \"Bolton Wanderers\" \"Everton FC\" \"Preston North End\" \"Stoke City\" ...\n $ away          : chr  \"Derby County\" \"Accrington FC\" \"Burnley FC\" \"West Bromwich Albion\" ...\n $ date          : Date, format: \"1888-09-08\" \"1888-09-08\" ...\n $ gh            : int  3 2 5 0 1 5 5 3 1 2 ...\n $ ga            : int  6 1 2 2 1 1 5 4 2 1 ...\n $ full_time     : chr  \"F\" \"F\" \"F\" \"F\" ...\n $ competition   : chr  \"england\" \"england\" \"england\" \"england\" ...\n $ home_ident    : chr  \"Bolton Wanderers (England)\" \"Everton FC (England)\" \"Preston North End (England)\" \"Stoke City (England)\" ...\n $ away_ident    : chr  \"Derby County (England)\" \"Accrington FC (England)\" \"Burnley FC (England)\" \"West Bromwich Albion (England)\" ...\n $ home_country  : chr  \"england\" \"england\" \"england\" \"england\" ...\n $ away_country  : chr  \"england\" \"england\" \"england\" \"england\" ...\n $ home_code     : chr  \"ENG\" \"ENG\" \"ENG\" \"ENG\" ...\n $ away_code     : chr  \"ENG\" \"ENG\" \"ENG\" \"ENG\" ...\n $ home_continent: chr  \"Europe\" \"Europe\" \"Europe\" \"Europe\" ...\n $ away_continent: chr  \"Europe\" \"Europe\" \"Europe\" \"Europe\" ...\n $ continent     : chr  \"Europe\" \"Europe\" \"Europe\" \"Europe\" ...\n $ level         : chr  \"national\" \"national\" \"national\" \"national\" ...\n```\n\n\n:::\n:::\n\n\n\nI am not going to measure the time it takes to convert the data to the needed format of the packages but just do it beforehand\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_tbl <- data\ndata_duck <- as_duckdb_tibble(data)\ndata_dt <- as.data.table(data)\ndata_pl <- as_polars_df(data)\n```\n:::\n\n\n\n## Summarise\n\nThe summarise task is pretty simple: Calculate the average number of goals scored at home for each team.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres <- microbenchmark::microbenchmark(\n  times = 100,\n  dplyr = data_tbl |> summarise(mgh = mean(gh), .by = home),\n  duckdb = data_duck |> summarise(mgh = mean(gh), .by = home),\n  tidypolars = data_pl |> summarise(mgh = mean(gh), .by = home),\n  data.table = data_dt[, .(mgh = mean(gh)), by = .(home)],\n  rpolars = data_pl$group_by(\"home\")$agg(\n    pl$col(\"gh\")$mean()$alias(\"mgh\")\n  ),\n  collapse = data_tbl |> fgroup_by(home) |> fsummarise(mgh = mean(gh))\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in microbenchmark::microbenchmark(times = 100, dplyr =\nsummarise(data_tbl, : less accurate nanosecond times to avoid potential integer\noverflows\n```\n\n\n:::\n\n```{.r .cell-code}\nggplot2::autoplot(res, order = \"median\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/bench-summarise-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n\n\n|expr       |       min|        lq|       mean|    median|        uq|        max| neval|\n|:----------|---------:|---------:|----------:|---------:|---------:|----------:|-----:|\n|duckdb     |   535.255|   930.782|   975.5552|  1003.270|  1041.359|   2109.532|   100|\n|data.table |  8466.336|  9103.620| 11070.6416|  9391.296| 10083.130|  83655.990|   100|\n|rpolars    |  8865.922|  9778.111| 10859.3018| 10492.700| 11356.447|  28230.509|   100|\n|collapse   | 19025.927| 20617.239| 23333.6588| 22573.144| 24203.141|  83712.775|   100|\n|tidypolars | 26773.164| 27874.383| 30603.9724| 28917.894| 31457.804|  55405.227|   100|\n|dplyr      | 43889.680| 48724.380| 52037.4189| 50061.041| 52284.840| 145506.581|   100|\n\n\n:::\n:::\n\n\n\nIt is quite impressive how `duckplyr` is an order of magnitude faster than every other library. \n`data.table` and `rpolars` are the next fastest. Notably, there seems to be some overhead for the \n`tidypolars` package which loses some of the speed of `rpolars`.\nOne has to note here though that both polars based packages are still under heavy development. Also,\nas the author Etienne points out in the comments, the overhead is constant so as soon as you work with really\nlarge data, you will not notice the difference as much anymore.\n\n\n## Join\n\nThe task for the join test os also quite straightforward. Calculate the average number of goals at home and away per team and join the resulting tables. For this task, we need to create individual join functions.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\njoin_dplyr <- function(df) {\n  home <- df |>\n    summarise(mgh = mean(gh), .by = home) |>\n    rename(team = home)\n  away <- df |>\n    summarise(mga = mean(ga), .by = away) |>\n    rename(team = away)\n  full_join(home, away, by = \"team\")\n}\n\njoin_duck <- join_tpl <- join_dplyr\n\njoin_dt <- function(df) {\n  home <- df[, .(mgh = mean(gh)), by = .(home)]\n  away <- df[, .(mga = mean(ga)), by = .(away)]\n  setnames(home, \"home\", \"team\")\n  setnames(away, \"away\", \"team\")\n  setkey(home, team)\n  setkey(away, team)\n  home[away, on = .(team), all = TRUE]\n}\n\njoin_pl <- function(df) {\n  home <- data_pl$group_by(\"home\")$agg(pl$col(\"gh\")$mean()$alias(\"mgh\"))\n  away <- data_pl$group_by(\"away\")$agg(pl$col(\"ga\")$mean()$alias(\"mga\"))\n  home <- home$rename(\"home\" = \"team\")\n  away <- away$rename(\"away\" = \"team\")\n  home$join(away, on = \"team\", how = \"full\")\n}\n\njoin_collapse <- function(df) {\n  home <- df |>\n    fgroup_by(home) |>\n    fsummarise(mgh = mean(gh)) |>\n    frename(team = home)\n  away <- df |>\n    fgroup_by(away) |>\n    fsummarise(mga = mean(ga)) |>\n    frename(team = away)\n  join(home, away, on = \"team\", how = \"full\", verbose = 0)\n}\n```\n:::\n\n\n\nHere you see the advantage of `tidypolars` and `duckplyr`. Both can simply reuse the `dplyr` function and the packages do the magic in the background.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres <- microbenchmark::microbenchmark(\n  times = 100,\n  dplyr = join_dplyr(data_tbl),\n  duckplyr = join_dplyr(data_duck),\n  tidypolars = join_tpl(data_pl),\n  data.table = join_dt(data_dt),\n  rpolars = join_pl(data_pl),\n  collapse = join_collapse(data_tbl)\n)\n\nggplot2::autoplot(res, order = \"median\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n\n\n|expr       |        min|         lq|       mean|     median|         uq|       max| neval|\n|:----------|----------:|----------:|----------:|----------:|----------:|---------:|-----:|\n|duckplyr   |   3.694387|   4.606924|   5.091219|   4.880948|   5.191584|  11.76397|   100|\n|rpolars    |  21.584614|  23.764973|  25.537319|  25.761243|  26.898419|  31.67016|   100|\n|data.table |  21.965463|  23.529018|  29.923670|  29.180827|  35.637979|  60.86544|   100|\n|collapse   |  39.202191|  42.658758|  48.035470|  44.975975|  46.738565| 148.10971|   100|\n|tidypolars |  57.399139|  61.233336|  65.124748|  64.182056|  68.485395|  94.56215|   100|\n|dplyr      | 134.835511| 143.749116| 150.810569| 148.957776| 152.985637| 254.70332|   100|\n\n\n:::\n:::\n\n\n\nThe results remain pretty much the same as before. `duckplyr` is much faster than the remaining libraries, with `rpolars` and `data.table` on a similar level as the second best options.\n\n## Summary\n\nAs I said in the beginning, this was not a very comprehensive benchmark, but tailored to my personal use case scenarios. I would be really interested in more rigorous benchmarks but till then, I will happily switch to `duckplyr` for my backend.",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}