{
  "hash": "762abd3f5252dfbcaaf569ce768119ea",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Rust in R beyond vectors\"\nauthor:\n  - name: David Schoch\n    orcid: 0000-0003-2952-4812\ndate: 2025-01-29\ncategories: [R, rust]\n---\n\n\n\n\nI have blogged about using Rust in R twice before. Once about a [phone number parser](https://blog.schochastics.net/posts/2024-02-23_parsing-phone-numbers-with-rust-and-r/) called [dialrs](https://github.com/schochastics/dialrs) and once about a [datetime parser](https://blog.schochastics.net/posts/2024-02-27_chronos-fast-general-purpose-datetime-converter/) called [timeless](https://github.com/schochastics/timeless). There is a actually third post about [the archival of timeless](https://blog.schochastics.net/posts/2024-09-25_tales-from-os-dev-001) on CRAN due to \nsome issues with the Rust policies. Both packages are really rudimentary in terms of the included Rust code. After all, I am still a beginner and quite happy if I get anything to run at all. So this should also serve as a disclaimer for this post. Take any Rust code you see here with a grain of salt. Just because it works, doesn't mean it is the best way (or even correct way). If you have suggestions or spotted big errors, please leave a comment.\n\n## Returning vectors in Rust functions\n\nWhat I meant with \"rudimentary\" above is that both packages only wrap one or two [crates](https://crates.io/)  and the most complex return values are vectors of strings, 'Vec<String>' in Rust terminology.\n\nHere is for example a function that parses international phone numbers from `dialrs`\n```rust\nfn parse_phone_rs_international(phone: Vec<String>, country: &str) -> Vec<String> {\n    let region = phonenumber::country::Id::from_str(country).ok();\n    phone\n        .into_iter()\n        .map(\n            |input| match phonenumber::parse(region, strip_hyphens(&input)) {\n                Ok(number) => number.format().mode(Mode::International).to_string(),\n                Err(_e) => String::new(),\n            },\n        )\n        .collect()\n}\n```\nand here is a function from `timeless` which tries to parse datetime from a string\n```rust\nfn parse_guess_rs(times: Vec<String>) -> Vec<String> {\n    times\n        .iter()\n        .map(|input| match input.parse::<DateTimeUtc>() {\n            Ok(value) => value\n                .0\n                .format(\"%Y-%m-%d %H:%M:%S\")\n                .to_string(),\n            Err(_e) => \"not found\".to_string(),\n        })\n        .collect()\n}\n```\n\n\nThe input and output in both cases are just character vectors. [rextendr](https://github.com/extendr/rextendr) can deal with these return type (vectors) without issues. But what if we want to move beyond simple vectors?\n\n## (Trying to) Return matrices in Rust functions\n\nWith my limited experience, I thought that something like `Vec<Vec<String>>` could be the right structure to return something \"2 dimensional\". While it actually does represent a 2D array-like structure, it does not enforce a strict rectangular shape. So each inner vector can have different lengths. So somewhat comparable to a List in R where all entries have to have the same type. So lets try to assemble a matrix-like list thing.\nBefore showing the Rust code, here is the equivalent in R.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreate_matrix <- function(n, m) {\n  lapply(seq_len(n), function(r) (1:m) + (r - 1) * m)\n}\ncreate_matrix(n = 3, m = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1 2 3 4\n\n[[2]]\n[1] 5 6 7 8\n\n[[3]]\n[1]  9 10 11 12\n```\n\n\n:::\n:::\n\n\n\n\nNow this is what it would look like in Rust.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrextendr::rust_function(\n  \"fn create_matrix(n: usize, m: usize) -> Vec<Vec<usize>> {\n    (0..n).map(|i| {\n        (0..m).map(|j| i * m + j + 1).collect()\n    }).collect()\n  }\"\n)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `invoke_cargo()`:\n! Rust code could not be compiled successfully. Aborting.\n✖ error[E0277]: the trait bound `extendr_api::Robj: From<Vec<Vec<usize>>>` is not satisfied\n --> src/lib.rs:2:1\n  |\n2 | #[extendr]\n  | ^^^^^^^^^^ the trait `From<Vec<Vec<usize>>>` is not implemented for `extendr_api::Robj`\n  |\n  = help: the following other types implement trait `From<T>`:\n            `extendr_api::Robj` implements `From<&Altrep>`\n            `extendr_api::Robj` implements `From<&Primitive>`\n            `extendr_api::Robj` implements `From<&Vec<T>>`\n            `extendr_api::Robj` implements `From<&[T; N]>`\n            `extendr_api::Robj` implements `From<&[T]>`\n            `extendr_api::Robj` implements `From<&extendr_api::Complexes>`\n            `extendr_api::Robj` implements `From<&extendr_api::Doubles>`\n            `extendr_api::Robj` implements `From<&extendr_api::Environment>`\n          and 63 others\n  = note: this error originates in the attribute macro `extendr` (in Nightly builds, run with -Z macro-backtrace for more info)\n```\n\n\n:::\n:::\n\n\n\n\nOk so this doesnt work. There is a lot going on in that error message but the important part is\n```\nthe trait `From<Vec<Vec<usize>>>` is not implemented for `extendr_api::Robj`\n``` \n\nWhat it tries to tell us is that we can't have `<Vec<Vec<usize>>` as a return value because it is not supported by the API that connects R and Rust.\n\nLet us try it with the [nalgebra](https://crates.io/crates/nalgebra) crate which allows us to actually build matrices.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncode <- r\"(\n  use nalgebra::DMatrix;\n\n  #[extendr]\n  fn create_matrix(n: usize, m: usize) -> DMatrix<usize> {\n      DMatrix::from_iterator(n, m, (1..=n * m))\n  }\n)\"\n\n\nrextendr::rust_source(\n  code = code,\n  dependencies = list(`nalgebra` = \"0.33\")\n)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `invoke_cargo()`:\n! Rust code could not be compiled successfully. Aborting.\n✖ error[E0277]: the trait bound `Matrix<usize, Dyn, Dyn, VecStorage<usize, Dyn, Dyn>>: ToVectorValue` is not satisfied\n --> src/lib.rs:5:3\n  |\n5 |   #[extendr]\n  |   ^^^^^^^^^^ the trait `ToVectorValue` is not implemented for `Matrix<usize, Dyn, Dyn, VecStorage<usize, Dyn, Dyn>>`\n  |\n  = help: the following other types implement trait `ToVectorValue`:\n            &&str\n            &(f64, f64)\n            &Rbool\n            &Rcplx\n            &Rfloat\n            &Rint\n            &String\n            &bool\n          and 45 others\n  = note: required for `extendr_api::Robj` to implement `From<Matrix<usize, Dyn, Dyn, VecStorage<usize, Dyn, Dyn>>>`\n  = note: this error originates in the attribute macro `extendr` (in Nightly builds, run with -Z macro-backtrace for more info)\n```\n\n\n:::\n:::\n\n\n\n\nThis looks pretty much like the same error. Something is not implemented that we need to transfer the Matrix to R. Maybe it is time to RTFM to understand what is going on.\n\n## The R/Rust interface\n \nOur situation is actually well described in the (work in progress) [user guide](https://extendr.github.io/user-guide/) of the crate `extendr-api` in the section about [macros](https://extendr.github.io/user-guide/type-mapping/extendr-macro.html). In order for an item to be returned to R from a function written in Rust, the return value must be able to be turned into an R object. This makes a lot of sense. Obviously, if R gets something that it doesn't understand, it cannot deal with it. But there is a way to MAKE R understand, even if it does not understand the original result.\n\nThe `ToVectorValue` trait is what is used to convert Rust items into R objects. We have seen this pop up in the last error message we got from the `nalgebra` crate. The trait is implemented on a number of standard Rust types such as i32, f64, usize, String and many more. So if any of these are returned, R knows what to do. \n\nYou might now ask yourself: \"What the hell is a trait?\". It has something to do with types (something we do not care much about in R). Say you want to write a simple function to sum up two values:\n\n```rust\nfn add(x: i32, y: i32) -> i32 {\n    x + y\n}\n```\n\nThis is fine, but as soon as you give this function something else than a `i32`, it errors. So if we want `add` to work for other types, we would have to create a function for every single number type there is (u32, f64 etc.). That would be quite cumbersome. How can we abstract this? The answer is traits. \n\n```rust\nuse std::ops::Add;\n\nfn add<T: Add>(x: T, y: T) -> T {\n    x + y\n}\n```\n\nThe trait `Add`, which looks like this\n\n```rust\ntrait Add<Rhs = Self> {\n    type Output;\n\n    fn add(self, rhs: Rhs) -> Self::Output;\n}\n``` \n\nimplements addition for a large variety of types (see [here](https://doc.rust-lang.org/nightly/std/ops/trait.Add.html#implementors)). But even if the type you need is not supported, you can implement it yourself with an `impl` block. \n\n\n## Implementing addition for a new struct\nSay we have defined our own structure, a point, and we want to define addition of points.\n\n```rust\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Add for Point {\n    type Output = Self;\n\n    fn add(self, other: Self) -> Self {\n        Self {\n            x: self.x + other.x,\n            y: self.y + other.y,\n        }\n    }\n}\n```\n\nIn this example we define a structure that is a point with two `i32` coordinates and the `impl` block tells Rust how to use the Add trait for this structure. But as you might realize, we have again only defined the structure for one specific type, `i32`. We can extend it in a very similar way as above.\n\n```rust\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n\nimpl<T: Add<Output = T>> Add for Point<T> {\n    type Output = Self;\n\n    fn add(self, other: Self) -> Self::Output {\n        Self {\n            x: self.x + other.x,\n            y: self.y + other.y,\n        }\n    }\n}\n```\n\nIn pure Rust, you can now do\n\n```rust\nlet p1 = Point { x: 1, y: 0 };\nlet p2 = Point { x: 2, y: 3 };\nlet p3 = p1 + p2;\n```\n\n## Bring it to R\n\nOk so that works in Rust, but how can we get this in R now?\nMy hope was, that I can just wrap the whole thing with rextendr and let it do its magic.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncode <- r\"(\nuse std::ops::Add;\n\n#[derive(Debug, Copy, Clone, PartialEq)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Add for Point {\n    type Output = Self;\n\n    fn add(self, other: Self) -> Self {\n        Self {\n            x: self.x + other.x,\n            y: self.y + other.y,\n        }\n    }\n}\n)\"\n\nrextendr::rust_source(\n  code = code\n)\n```\n:::\n\n\n\n\nIt actually does compile without an error, but there is nothing exported in R that we can use. After some testing, what we have to do is expose Point struct via an `impl` block and also expose the add function for points.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncode <- r\"(\nuse std::ops::Add;\n\n#[derive(Debug, Copy, Clone, PartialEq)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Add for Point {\n    type Output = Self;\n\n    fn add(self, other: Self) -> Self {\n        Self {\n            x: self.x + other.x,\n            y: self.y + other.y,\n        }\n    }\n}\n\n#[extendr]\nimpl Point {\n    fn new(x: i32, y: i32) -> Self {\n        Self { x, y }\n    }\n\n    fn to_vec(&self) -> Vec<i32> {\n        vec![self.x, self.y]\n    }\n}\n\n#[extendr]\nfn add_points(p1: Point, p2: Point) -> Point {\n    p1 + p2\n}\n)\"\n\nrextendr::rust_source(\n  code = code\n)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `invoke_cargo()`:\n! Rust code could not be compiled successfully. Aborting.\n✖ error[E0277]: the trait bound `Point: extendr_api::TryFrom<extendr_api::Robj>` is not satisfied\n  --> src/lib.rs:33:1\n   |\n33 | #[extendr]\n   | ^^^^^^^^^^ the trait `From<extendr_api::Robj>` is not implemented for `Point`\n   |\n   = note: required for `extendr_api::Robj` to implement `Into<Point>`\n   = note: required for `Point` to implement `extendr_api::TryFrom<extendr_api::Robj>`\n   = note: required for `extendr_api::Robj` to implement `extendr_api::TryInto<Point>`\n   = note: this error originates in the attribute macro `extendr` (in Nightly builds, run with -Z macro-backtrace for more info)\n```\n\n\n:::\n:::\n\n\n\n\nUnfortunately, this does not work yet. The error says\n```\nthe trait `From<extendr_api::Robj>` is not implemented for `Point`\n```\n\nUp to now, we have done everything so that R understands when it gets an object of type Point. But given that the function `add_points()` also has Point as input, we now need to make Rust understand when it gets a Point from R. This is done with a TryFrom block.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#\ncode <- r\"(\nuse std::ops::Add;\nuse extendr_api::*;\n#[derive(Debug, Copy, Clone, PartialEq)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Add for Point {\n    type Output = Self;\n\n    fn add(self, other: Self) -> Self {\n        Self {\n            x: self.x + other.x,\n            y: self.y + other.y,\n        }\n    }\n}\n\nimpl TryFrom<Robj> for Point {\n    type Error = Error;\n\n    fn try_from(robj: Robj) -> Result<Self> {\n        let vec: Vec<i32> = robj.as_integer_vector()\n            .ok_or_else(|| Error::Other(\"Expected an integer vector of length 2\".into()))?;\n        if vec.len() != 2 {\n            return Err(Error::Other(\"Point requires exactly two integers\".into()));\n        }\n        Ok(Point { x: vec[0], y: vec[1] })\n    }\n}\n\n#[extendr]\nimpl Point {\n    fn new(x: i32, y: i32) -> Self {\n        Self { x, y }\n    }\n\n    fn to_vec(&self) -> Vec<i32> {\n        vec![self.x, self.y]\n    }\n}\n\n#[extendr]\nfn add_points(p1: Point, p2: Point) -> Point {\n    p1 + p2\n}\n)\"\n\nrextendr::rust_source(\n  code = code\n)\n```\n:::\n\n\n\n\nSeems to be fine so lets try and use it.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- Point$new(3L, 4L)\np2 <- Point$new(1L, 2L)\np1$to_vec()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 4\n```\n\n\n:::\n\n```{.r .cell-code}\np3 <- add_points(p1, p2)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in add_points(p1, p2): Expected an integer vector of length 2\n```\n\n\n:::\n:::\n\n\n\n\nIntuitively, I would have thought that this should work. But ultimately, I think it is clear why it doesnt. The TryFrom expects an integer vector of length two comming from R, not a Point object. So what will work is\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np3 <- add_points(c(3L, 4L), c(1L, 2L))\np3$to_vec()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 6\n```\n\n\n:::\n:::\n\n\n\n\nGreat, we managed with much trial-and-error to get a proper implementation. \n\nFor completeness,\nhere is another version of the code that is a bit shorter and lets us do the addition with actual point type objects.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncode <- r\"(\nuse extendr_api::prelude::*;\nuse std::ops::Add;\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub struct Point {\n    x: i32,\n    y: i32,\n}\n\n#[extendr]\nimpl Point {\n    fn new(x: i32, y: i32) -> Self {\n        Point { x, y }\n    }\n\n    fn add(&self, other: &Point) -> Point {\n        *self + *other\n    }\n\n    fn to_vec(&self) -> Vec<i32> {\n        vec![self.x, self.y]\n    }\n}\n\nimpl Add for Point {\n    type Output = Point;\n\n    fn add(self, other: Point) -> Point {\n        Point {\n            x: self.x + other.x,\n            y: self.y + other.y,\n        }\n    }\n}\n)\"\n\nrextendr::rust_source(\n  code = code\n)\n```\n:::\n\n\n\n\nWe do have the same addition trait, but now we define the actual function within the Point block. That way, we can use it as follows\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- Point$new(3L, 4L)\np2 <- Point$new(1L, 2L)\np1$add(p2)$to_vec()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 6\n```\n\n\n:::\n:::\n\n\n\n\n## Conclusion\n\nWe might not have implemented anything useful here, but I hope the rudimentary example tought as a few things.\n\n- **Batteries included**: If all you do is moving vectors with standard type between R and Rust, you should be fine in most cases\n\n- **Interface between R and Rust**: We need `impl` blocks and `TryFrom` to make R and Rust understand each other better for types that are not so standard.\n\n- **Read the compiler messages**: I skipped some intermediary steps in my exploration, because there was much more trial-and-error than I showed. Many things can be fixed simply by reading the error messages provided by the compiler. In many cases, it let's you know what the fix is.\n\n## Addendum\n\nShortly after publishing this post, I found that `extendr-api` actually supports matrices in some way ([link](https://docs.rs/extendr-api/latest/extendr_api/wrapper/matrix/type.RMatrix.html)). I try to explore this in a later post.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}