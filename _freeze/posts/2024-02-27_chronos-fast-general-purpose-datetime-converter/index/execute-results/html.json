{
  "hash": "390b1e31dbd19249e86479a067be5105",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: 'timeless: A fast general purpose datetime parser'\nauthor:\n- name: David Schoch\n  orcid: 0000-0003-2952-4812\ndate: '2024-02-27'\ncategories:\n- R\n- package\n- Rust\nexecute: \n  warning: false\n---\n\n\n\n\n**Update II**: \n**The package was renamed from `chronos` to `timeless` due to a name clash with a Biocundoctor package.**\n\n**Update I**:  \n*The code of this post was rerun 2024-02-28 after a small [performance boost](https://github.com/schochastics/chronos/issues/13) was implemented.*\n\nThis post introduces the R package [timeless](https://github.com/schochastics/timeless/), a fast general purpose date/time converter written in Rust with crates [dateparser](https://crates.io/crates/dateparser) and [chrono](https://crates.io/crates/chrono). This is the second outcome of my adventure of [learning Rust](http://blog.schochastics.net/posts/2024-02-23_parsing-phone-numbers-with-rust-and-r/).[^1] \n\nThe package essentially does what [anytime](https://github.com/eddelbuettel/anytime) does, but it appears to do so a bit more efficiently.\n\n![](logo.png){fig-align=\"center\"}\n\n## Installation\n\nYou can install the development version of timeless like so:\n\n``` r\nremotes::install_github(\"schochastics/timeless\")\n#or\npak::pak(\"schochastics/timeless\")\n```\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(timeless)\n```\n:::\n\n\n\n\n## Formats\n\n`timeless` understands many different date(time) formats out of the box. A subset is included as a small benchmark dataset.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench_date\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"1511648546\"                          \"1620021848429\"                      \n [3] \"1620024872717915000\"                 \"2021-05-01T01:17:02.604456Z\"        \n [5] \"2017-11-25T22:34:50Z\"                \"Wed, 02 Jun 2021 06:31:39 GMT\"      \n [7] \"2019-11-29 08:08-08\"                 \"2019-11-29 08:08:05-08\"             \n [9] \"2021-05-02 23:31:36.0741-07\"         \"2021-05-02 23:31:39.12689-07\"       \n[11] \"2019-11-29 08:15:47.624504-08\"       \"2017-07-19 03:21:51+00:00\"          \n[13] \"2014-04-26 05:24:37 PM\"              \"2021-04-30 21:14\"                   \n[15] \"2021-04-30 21:14:10\"                 \"2021-04-30 21:14:10.052282\"         \n[17] \"2014-04-26 17:24:37.123\"             \"2014-04-26 17:24:37.3186369\"        \n[19] \"2012-08-03 18:31:59.257000000\"       \"2017-11-25 13:31:15 PST\"            \n[21] \"2017-11-25 13:31 PST\"                \"2014-12-16 06:20:00 UTC\"            \n[23] \"2014-12-16 06:20:00 GMT\"             \"2014-04-26 13:13:43 +0800\"          \n[25] \"2014-04-26 13:13:44 +09:00\"          \"2012-08-03 18:31:59.257000000 +0000\"\n[27] \"2015-09-30 18:48:56.35272715 UTC\"    \"2021-02-21\"                         \n[29] \"2021-02-21 PST\"                      \"2021-02-21 UTC\"                     \n[31] \"2020-07-20+08:00\"                    \"01:06:06\"                           \n[33] \"4:00pm\"                              \"6:00 AM\"                            \n[35] \"01:06:06 PST\"                        \"4:00pm PST\"                         \n[37] \"6:00 AM PST\"                         \"6:00pm UTC\"                         \n[39] \"May 6 at 9:24 PM\"                    \"May 27 02:45:27\"                    \n[41] \"May 8, 2009 5:57:51 PM\"              \"September 17, 2012 10:09am\"         \n[43] \"September 17, 2012, 10:10:09\"        \"May 02, 2021 15:51:31 UTC\"          \n[45] \"May 02, 2021 15:51 UTC\"              \"May 26, 2021, 12:49 AM PDT\"         \n[47] \"September 17, 2012 at 10:09am PST\"   \"2021-Feb-21\"                        \n[49] \"May 25, 2021\"                        \"oct 7, 1970\"                        \n[51] \"oct 7, 70\"                           \"oct. 7, 1970\"                       \n[53] \"oct. 7, 70\"                          \"October 7, 1970\"                    \n[55] \"12 Feb 2006, 19:17\"                  \"12 Feb 2006 19:17\"                  \n[57] \"14 May 2019 19:11:40.164\"            \"7 oct 70\"                           \n[59] \"7 oct 1970\"                          \"03 February 2013\"                   \n[61] \"1 July 2013\"                         \"4/8/2014 22:05\"                     \n[63] \"04/08/2014 22:05\"                    \"4/8/14 22:05\"                       \n[65] \"04/2/2014 03:00:51\"                  \"8/8/1965 12:00:00 AM\"               \n[67] \"8/8/1965 01:00:01 PM\"                \"8/8/1965 01:00 PM\"                  \n[69] \"8/8/1965 1:00 PM\"                    \"8/8/1965 12:00 AM\"                  \n[71] \"4/02/2014 03:00:51\"                  \"03/19/2012 10:11:59\"                \n[73] \"03/19/2012 10:11:59.3186369\"         \"3/31/2014\"                          \n[75] \"03/31/2014\"                          \"08/21/71\"                           \n[77] \"8/1/71\"                              \"2014/4/8 22:05\"                     \n[79] \"2014/04/08 22:05\"                    \"2014/04/2 03:00:51\"                 \n[81] \"2014/4/02 03:00:51\"                  \"2012/03/19 10:11:59\"                \n[83] \"2012/03/19 10:11:59.3186369\"         \"2014/3/31\"                          \n[85] \"2014/03/31\"                          \"3.31.2014\"                          \n[87] \"03.31.2014\"                          \"08.21.71\"                           \n[89] \"2014.03.30\"                          \"2014.03\"                            \n[91] \"171113 14:14:20\"                     \"2014年04月08日11时25分18秒\"         \n[93] \"2014年04月08日\"                     \n```\n\n\n:::\n:::\n\n\n\n\n`chronos()` is the powerhouse of the package and tries as hard as possible to parse every input into either\na date or a datetime, depending on `out_format`. The function can also return a raw character vector which can be fed into faster\nconverters, such as [fasttime](https://github.com/s-u/fasttime).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchronos(bench_date, out_format = \"datetime\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"2017-11-25 22:22:26 CET\"  \"2021-05-03 06:04:08 CEST\"\n [3] \"2021-05-03 06:54:32 CEST\" \"2021-05-01 01:17:02 CEST\"\n [5] \"2017-11-25 22:34:50 CET\"  \"2021-06-02 06:31:39 CEST\"\n [7] \"2019-11-29 16:08:00 CET\"  \"2019-11-29 08:08:05 CET\" \n [9] \"2021-05-02 23:31:36 CEST\" \"2021-05-02 23:31:39 CEST\"\n[11] \"2019-11-29 08:15:47 CET\"  \"2017-07-19 03:21:51 CEST\"\n[13] \"2014-04-26 15:24:37 CEST\" \"2021-04-30 19:14:00 CEST\"\n[15] \"2021-04-30 21:14:10 CEST\" \"2021-04-30 21:14:10 CEST\"\n[17] \"2014-04-26 17:24:37 CEST\" \"2014-04-26 17:24:37 CEST\"\n[19] \"2012-08-03 18:31:59 CEST\" \"2017-11-25 21:31:15 CET\" \n[21] \"2017-11-25 21:31:00 CET\"  \"2014-12-16 06:20:00 CET\" \n[23] \"2014-12-16 06:20:00 CET\"  \"2014-04-26 05:13:43 CEST\"\n[25] \"2014-04-26 04:13:44 CEST\" \"2012-08-03 18:31:59 CEST\"\n[27] \"2015-09-30 18:48:56 CEST\" \"2021-02-21 13:31:31 CET\" \n[29] \"2021-02-21 13:31:31 CET\"  \"2021-02-21 13:31:31 CET\" \n[31] \"2020-07-20 13:31:31 CEST\" \"2025-01-30 00:06:06 CET\" \n[33] \"2025-01-30 15:00:00 CET\"  \"2025-01-30 05:00:00 CET\" \n[35] \"2025-01-30 09:06:06 CET\"  \"2025-01-31 00:00:00 CET\" \n[37] \"2025-01-30 14:00:00 CET\"  \"2025-01-30 18:00:00 CET\" \n[39] \"2025-05-06 19:24:00 CEST\" \"2025-05-27 00:45:27 CEST\"\n[41] \"2009-05-08 15:57:51 CEST\" \"2012-09-17 08:09:00 CEST\"\n[43] \"2012-09-17 08:10:09 CEST\" \"2021-05-02 15:51:31 CEST\"\n[45] \"2021-05-02 15:51:00 CEST\" \"2021-05-26 07:49:00 CEST\"\n[47] \"2012-09-17 18:09:00 CEST\" \"2021-02-21 13:31:31 CET\" \n[49] \"2021-05-25 12:31:31 CEST\" \"1970-10-07 13:31:31 CET\" \n[51] \"1970-10-07 13:31:31 CET\"  \"1970-10-07 13:31:31 CET\" \n[53] \"1970-10-07 13:31:31 CET\"  \"1970-10-07 13:31:31 CET\" \n[55] \"2006-02-12 18:17:00 CET\"  \"2006-02-12 18:17:00 CET\" \n[57] \"2019-05-14 17:11:40 CEST\" \"1970-10-07 13:31:31 CET\" \n[59] \"1970-10-07 13:31:31 CET\"  \"2013-02-03 13:31:31 CET\" \n[61] \"2013-07-01 12:31:31 CEST\" \"2014-04-08 20:05:00 CEST\"\n[63] \"2014-04-08 20:05:00 CEST\" \"2014-04-08 20:05:00 CEST\"\n[65] \"2014-02-04 03:00:51 CET\"  \"1965-08-07 23:00:00 CET\" \n[67] \"1965-08-08 12:00:01 CET\"  \"1965-08-08 13:00:00 CET\" \n[69] \"1965-08-08 13:00:00 CET\"  \"1965-08-08 00:00:00 CET\" \n[71] \"2014-02-04 03:00:51 CET\"  \"2012-03-19 10:11:59 CET\" \n[73] \"2012-03-19 09:11:59 CET\"  \"2014-03-31 12:31:31 CEST\"\n[75] \"2014-03-31 12:31:31 CEST\" \"1971-08-21 13:31:31 CET\" \n[77] \"1971-08-01 13:31:31 CET\"  \"2014-04-08 20:05:00 CEST\"\n[79] \"2014-04-08 20:05:00 CEST\" \"2014-04-02 03:00:51 CEST\"\n[81] \"2014-04-02 03:00:51 CEST\" \"2012-03-19 10:11:59 CET\" \n[83] \"2012-03-19 09:11:59 CET\"  \"2014-03-31 12:31:31 CEST\"\n[85] \"2014-03-31 12:31:31 CEST\" \"2014-03-31 12:31:31 CEST\"\n[87] \"2014-03-31 12:31:31 CEST\" \"1971-08-21 13:31:31 CET\" \n[89] \"2014-03-30 12:31:31 CEST\" \"2014-03-30 12:31:31 CEST\"\n[91] \"2017-11-13 13:14:20 CET\"  \"2014-04-08 09:25:18 CEST\"\n[93] \"2014-04-08 12:31:31 CEST\"\n```\n\n\n:::\n:::\n\n\n\n\n## Functions\n\nUnder the hood `chronos()` calls three functions which can also be used in isolation:\n\n- `parse_datetime()`: a fast datetime parser that tries several different formats until it can parse the input\n\n- `parse_date()`: a fast date parser that tries several different formats until it can parse the input\n\n- `parse_epoch()`: a fast epoch timestamp parser\n\n## anytime\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(anytime)\n```\n:::\n\n\n\n\n[anytime](https://github.com/eddelbuettel/anytime) is certainly the most accepted general purpose date(time) converter to date.\n\nIt does not recognize all accepted formats of `timeless` out of the box. However, the unrecognized formats can easily be added via `anytime::addFormats()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::coalesce(\n  anytime(bench_date),\n  anydate(bench_date)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] NA                         \"1620-02-17 23:53:28 LMT\" \n [3] NA                         \"2021-05-01 01:17:02 CEST\"\n [5] \"2017-11-25 22:34:50 CET\"  \"2021-06-02 06:31:39 CEST\"\n [7] \"2019-11-29 08:08:08 CET\"  \"2019-11-29 08:08:05 CET\" \n [9] \"2021-05-02 23:31:36 CEST\" \"2021-05-02 23:31:39 CEST\"\n[11] \"2019-11-29 08:15:47 CET\"  \"2017-07-19 03:21:51 CEST\"\n[13] \"2014-04-26 05:24:37 CEST\" \"2021-04-30 21:14:00 CEST\"\n[15] \"2021-04-30 21:14:10 CEST\" \"2021-04-30 21:14:10 CEST\"\n[17] \"2014-04-26 17:24:37 CEST\" \"2014-04-26 17:24:37 CEST\"\n[19] \"2012-08-03 18:31:59 CEST\" \"2017-11-25 13:31:15 CET\" \n[21] \"2017-11-25 00:00:00 CET\"  \"2014-12-16 06:20:00 CET\" \n[23] \"2014-12-16 06:20:00 CET\"  \"2014-04-26 13:13:43 CEST\"\n[25] \"2014-04-26 13:13:44 CEST\" \"2012-08-03 18:31:59 CEST\"\n[27] \"2015-09-30 18:48:56 CEST\" \"2021-02-21 00:00:00 CET\" \n[29] \"2021-02-21 00:00:00 CET\"  \"2021-02-21 00:00:00 CET\" \n[31] \"2020-07-20 08:00:00 CEST\" NA                        \n[33] NA                         NA                        \n[35] NA                         NA                        \n[37] NA                         NA                        \n[39] NA                         NA                        \n[41] \"2009-05-08 00:00:00 CEST\" \"2012-09-17 00:00:00 CEST\"\n[43] \"2012-09-17 00:00:00 CEST\" \"2021-05-02 00:00:00 CEST\"\n[45] \"2021-05-02 00:00:00 CEST\" \"2021-05-26 00:00:00 CEST\"\n[47] \"2012-09-17 00:00:00 CEST\" \"2021-02-21 00:00:00 CET\" \n[49] \"2021-05-25 00:00:00 CEST\" \"1970-10-07 00:00:00 CET\" \n[51] NA                         \"1970-10-07 00:00:00 CET\" \n[53] NA                         \"1970-10-07 00:00:00 CET\" \n[55] \"2006-02-12 00:00:00 CET\"  \"2006-02-12 19:17:00 CET\" \n[57] \"2019-05-14 19:11:40 CEST\" NA                        \n[59] \"1970-10-07 00:00:00 CET\"  \"2013-02-03 00:00:00 CET\" \n[61] \"2013-07-01 00:00:00 CEST\" \"2014-04-08 22:05:00 CEST\"\n[63] \"2014-04-08 22:05:00 CEST\" NA                        \n[65] \"2014-04-02 03:00:51 CEST\" \"1965-08-08 00:00:00 CET\" \n[67] \"1965-08-08 00:00:00 CET\"  \"1965-08-08 00:00:00 CET\" \n[69] \"1965-08-08 00:00:00 CET\"  \"1965-08-08 00:00:00 CET\" \n[71] \"2014-04-02 03:00:51 CEST\" \"2012-03-19 10:11:59 CET\" \n[73] \"2012-03-19 10:11:59 CET\"  \"2014-03-31 00:00:00 CEST\"\n[75] \"2014-03-31 00:00:00 CEST\" NA                        \n[77] NA                         \"2014-04-08 22:05:00 CEST\"\n[79] \"2014-04-08 22:05:00 CEST\" \"2014-04-02 03:00:51 CEST\"\n[81] \"2014-04-02 03:00:51 CEST\" \"2012-03-19 10:11:59 CET\" \n[83] \"2012-03-19 10:11:59 CET\"  \"2014-03-31 00:00:00 CEST\"\n[85] \"2014-03-31 00:00:00 CEST\" \"2014-03-31 00:00:00 CEST\"\n[87] \"2014-03-31 00:00:00 CEST\" NA                        \n[89] \"2014-03-30 00:00:00 CET\"  \"2014-03-01 00:00:00 CET\" \n[91] \"1711-03-14 14:13:28 LMT\"  NA                        \n[93] NA                        \n```\n\n\n:::\n:::\n\n\n\n\nThe full list of formats supported can be retrieved with `anytime::getFormats()`. `timeless` implements all these formats natively too.\n\n## Benchmark\n\nThe benchmark is done with three datasets that contain a variety of different date(time) formats.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench_datetimes <- readLines(\"datetime1000.txt\")\nhead(bench_datetimes)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"28 December 1979 12:54AM\" \"12/21/1991 08:07 AM\"     \n[3] \"13-03-1979 19:51\"         \"2007-11-08 01:09:25\"     \n[5] \"May 29, 1978 07:57\"       \"2015-05-04 21:55:07\"     \n```\n\n\n:::\n\n```{.r .cell-code}\nbench_epochs <- readLines(\"epoch500.txt\")\nhead(bench_epochs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"717700128\" \"115153946\" \"948771719\" \"586380132\" \"795097964\" \"211051179\"\n```\n\n\n:::\n\n```{.r .cell-code}\nbench_dates <- readLines(\"dates500.txt\")\nhead(bench_dates)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"September 07, 2018\"         \"1991.02.14\"                \n[3] \"12:00 AM December 26, 2000\" \"April 05, 1996\"            \n[5] \"June 19, 2014\"              \"27-Jun-2016\"               \n```\n\n\n:::\n\n```{.r .cell-code}\nbench <- c(bench_datetimes, bench_epochs, bench_dates)\n```\n:::\n\n\n\n\n## Ability to parse\n\nThis benchmark just checks **if** something was parsed and does **not** say if the result is actually correct.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum_na <- function(x) sum(is.na(x))\ndata.frame(\n  type = c(\"datetimes\", \"epochs\", \"dates\", \"all\"),\n  chronos = c(\n    sum_na(chronos(bench_datetimes)),\n    sum_na(chronos(bench_epochs)),\n    sum_na(chronos(bench_dates, out_format = \"date\")),\n    sum_na(chronos(bench))\n  ),\n  anytime = c(\n    sum_na(anytime(bench_datetimes)),\n    sum_na(anytime(as.numeric(bench_epochs))),\n    sum_na(anydate(bench_dates)),\n    sum_na(anytime(bench))\n  )\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       type chronos anytime\n1 datetimes       0     322\n2    epochs       0       0\n3     dates       0     138\n4       all       0     949\n```\n\n\n:::\n:::\n\n\n\n\nWhen epoch times are encoded as characters (which happens when all data is put together in one vector), then anytime fails to parse most of the epoch times.\n\n## Runtime\n\nThe package [fasttime](https://github.com/s-u/fasttime) can be used together with `timeless` to convert larger sets of datetimes by letting chronos return a character vector which is then parsed by `fastPOSIXct` or `fastDate`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfast_chronos <- function(x, out_format = \"datetime\") {\n  res <- chronos(x, out_format = \"character\")\n  if (out_format == \"datetime\") {\n    return(fasttime::fastPOSIXct(res))\n  } else {\n    return(fasttime::fastDate(res))\n  }\n}\n```\n:::\n\n\n\n\n### Full data\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmb <- microbenchmark::microbenchmark(\n  chronos = chronos(bench),\n  fast_chronos = fast_chronos(bench),\n  anytime = anytime(bench),\n  times = 100L\n)\nggplot2::autoplot(mb)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/bench_all-1.png){width=672}\n:::\n:::\n\n\n\n\n### datetime\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmb <- microbenchmark::microbenchmark(\n  chronos = chronos(bench_datetimes),\n  fast_chronos = fast_chronos(bench_datetimes),\n  anytime = anytime(bench_datetimes),\n  times = 100L\n)\nggplot2::autoplot(mb)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/bench_datetime-1.png){width=672}\n:::\n:::\n\n\n\n\n### epoch\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench_epochs_num <- as.integer(bench_epochs)\nmb <- microbenchmark::microbenchmark(\n  chronos = chronos(bench_epochs_num),\n  fast_chronos = fast_chronos(bench_epochs_num),\n  anytime = anytime(bench_epochs_num),\n  posix = as.POSIXct(bench_epochs_num),\n  fastposix = fasttime::fastPOSIXct(bench_epochs_num),\n  times = 100L\n)\nggplot2::autoplot(mb)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/bench_epoch-1.png){width=672}\n:::\n:::\n\n\n\n\nWhen the input vector only consists of epoch timestamps, it is best to parse them directly with `as.POSIXct`.\n\n### date\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmb <- microbenchmark::microbenchmark(\n  chronos = chronos(bench_date, out_format = \"date\"),\n  fast_chronos = fast_chronos(bench_date, out_format = \"date\"),\n  anytime = anydate(bench_date),\n  times = 100L\n)\nggplot2::autoplot(mb)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/bench_date-1.png){width=672}\n:::\n:::\n\n\n\n\n## Disclaimer\nWhile it might seem that `timeless` has an edge over `anytime`, it is far less battle tested and\nmature (Date parsing can be as tricky as [URL parsing](http://blog.schochastics.net/posts/2023-10-01_adar-an-accurate-fast-and-whatwg-compliant-url-parser/)). I am grateful for anyone who can take the package for a spin and report issues/make feature requests.\n\n\n[^1]: I am now feeling more comfortable with the language and I am starting to really enjoy it. Pretty sure this will not be my last R package with Rust. \n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}