{
  "hash": "9f1f97f78bb6d9a2f00486022ec13c56",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Working with R data frames in Rust\"\nauthor:\n  - name: David Schoch\n    orcid: 0000-0003-2952-4812\ndate: 2024-01-30\ncategories: [R, rust]\n---\n\n\n\nThe content of this post is actually what I wanted to do in my [last](https://blog.schochastics.net/posts/2025-01-29_rust-in-r-beyond-vectors/). However, I went down so many rabbit holes when researching the topic that I decided to split it into a more general exploration of working with non-standard types and a post that is specifically dedicated to data frames.  \n\nI have to add the same disclaimer to this post as to the last: I am still a beginner in Rust, trying to figure things out. My main goal for now is not to write perfect/best practice Rust code, but to be able to call Rust from R (and send things to Rust from R) that goes beyond simple vectors and does what I want it to do.\n\n## Existing frameworks\n\nData frames in R are essential because they provide a structured, table-like format for handling heterogeneous data, seamlessly integrating numeric, character, and factor variables within a single dataset. Their flexibility, built-in functions, and compatibility with Râ€™s data manipulation packages (like the `tidyverse`) make them the go-to structure for efficient data analysis and visualization. \n\nFor general data science, there is the crate [polars](https://docs.rs/polars/latest/polars/). Polars is extremely powerful and we can already benefit from it in R with [r-polars](https://github.com/pola-rs/r-polars). The syntax might be a bit strange for newcomers, but there \nis [tidypolars](https://github.com/etiennebacher/tidypolars) which promisses to provide a polars backend for the `tidyverse`. What this essentially means is that you can keep your `tidyverse` code while using polars in the background. That is a pretty awesome prospect and we might see this far more use cases in the future. \n\nBut we are not as ambitious as creating a full fletched data science machinery in this post. All we want is to create a data frame in Rust and bring it to R.\n\n## Data frame support in `extendr-api`\n\nIn the last post, I tried to built a machinery that allows to move non-standard (anything not vector) types from R to Rust and back. That involved stuff like traits, `impl` and `TryFrom` blocks. Luckily, this is not needed for data frames. At least not for how I want to use them. `extendr-api` comes with a struct `Dataframe<T>` (a representation of a typed `data.frame`). A `data.frame` can be created from Rust with the trait `IntoDataFrameRow`. This trait can be derived for a single struct that represents a single row. The type of the row is then captured by the marker `T`. Now what does that mean?\n\nIn order to construct a `data.frame` row by row, we need to define a `struct` that tells Rust what a row of the final `data.frame` should look like.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncode <- r\"(\nuse extendr_api::prelude::*;\n\n#[derive(Debug,IntoDataFrameRow)]\nstruct Person {\n  first: String,\n  last: String,\n  age: i32\n}\n\n#[extendr]\nfn person2df(firstR: String, lastR: String, ageR: i32) -> Dataframe<Person> {\n  let v = vec![Person {first: firstR, last: lastR, age:ageR}];\n  let df = v.into_dataframe();\n  df.expect(\"Failed to return a data.frame\")\n}\n)\"\n\nrextendr::rust_source(\n  code = code\n)\n\ndf <- person2df(\"Alice\", \"Smith\", 31L)\nclass(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n\n```{.r .cell-code}\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  first  last age\n1 Alice Smith  31\n```\n\n\n:::\n:::\n\n\n\nNote that the type of the inport arguments is important! `firstR` and `lastR` need to be characters\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nperson2df(1, 2, 3)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in person2df(1, 2, 3): Expected Strings got Doubles\n```\n\n\n:::\n:::\n\n\n\n## Building a larger data frame\n\nThe function above is not very exciting. It can only return a one row data.frame and will never return more. What we need to do is to extend the function\nby allowing vector inputs. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncode <- r\"(\nuse extendr_api::prelude::*;\n\n#[derive(Debug, IntoDataFrameRow)]\nstruct Person {\n    first: String,\n    last: String,\n    age: i32,\n}\n\n#[extendr]\nfn people2df(firstR: Vec<String>, lastR: Vec<String>, ageR: Vec<i32>) -> Dataframe<Person> {\n    let len = firstR.len();\n    if lastR.len() != len || ageR.len() != len {\n        panic!(\"All input vectors must have the same length\");\n    }\n\n    let people: Vec<Person> = firstR.into_iter()\n        .zip(lastR.into_iter())\n        .zip(ageR.into_iter())\n        .map(|((first, last), age)| Person { first, last, age })\n        .collect();\n\n    people.into_dataframe().expect(\"Failed to return a data.frame\")\n}\n)\"\n\nrextendr::rust_source(\n  code = code\n)\n```\n:::\n\n\n\nMaybe some clarifications are needed here. `zip()` is a method in Rust that combines two iterators into a single iterator of tuples. Each tuple contains elements from both iterators at the same index. In our case, it creates something like nested tuples. First it combines `firstR` and `lastR` and then adds `ageR`. The final tuples then look like this:\n\n```\n((\"Alice\", \"Smith\"), 25)\n((\"Bob\", \"Johnson\"), 30)\n((\"Charlie\", \"Brown\"), 22)\n```\n\nThe `map()` method converts each typle into a object of type Person by converting `((first, last), age)` into `Person { first, last, age }`. \n`collect()` then creates a `Vec<Person>` out of this. Now lets see if this works.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- people2df(\n  firstR = c(\"Alice\", \"Bob\", \"Charlie\"),\n  lastR = c(\"Smith\", \"Johnson\", \"Brown\"),\n  ageR = c(31L, 12L, 22L)\n)\n\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    first    last age\n1   Alice   Smith  31\n2     Bob Johnson  12\n3 Charlie   Brown  22\n```\n\n\n:::\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}