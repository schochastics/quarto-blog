{
  "hash": "d98b6fd0379699e693c8bdabe690b567",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Creating data frames in Rust for R\nauthor:\n- name: David Schoch\n  orcid: 0000-0003-2952-4812\ndate: '2025-01-30'\ncategories:\n- R\n- Rust\n---\n\n\n\nThe content of this post is actually what I wanted to do in my [last](https://blog.schochastics.net/posts/2025-01-29_rust-in-r-beyond-vectors/). But I went down so many rabbit holes when researching the topic that I decided to split it into a more general exploration of working with non-standard types and a post that is specifically dedicated to data frames.  \n\nI have to add the same disclaimer to this post as to the last: I am still a beginner in Rust, trying to figure things out. My main goal for now is not to write perfect/best practice Rust code, but to be able to call Rust from R (and send things to R from Rust) that goes beyond simple vectors and does what I want it to do.\n\n## Existing frameworks\n\nData frames in R are essential because they provide a structured, table-like format for handling heterogeneous data, seamlessly integrating numeric, character, and factor variables within a single dataset. Their flexibility, built-in functions, and compatibility with Râ€™s data manipulation packages (like the `tidyverse`) make them the go-to structure for efficient data analysis and visualization. \n\nFor general data science, there is the crate [polars](https://docs.rs/polars/latest/polars/). Polars is extremely powerful and we can already benefit from it in R with [r-polars](https://github.com/pola-rs/r-polars). The syntax might be a bit strange for newcomers, but there \nis [tidypolars](https://github.com/etiennebacher/tidypolars) which promisses to provide a polars backend for the `tidyverse`. What this essentially means is that you can keep your `tidyverse` code while using polars in the background. That is a pretty awesome prospect and we might see this far more use cases in the future. \n\nBut we are not as ambitious as creating a full fletched data science machinery in this post. All we want is to create a data frame in Rust and bring it to R.\n\n## Data frame support in `extendr-api`\n\nIn the last post, I tried to built something that allows to move non-standard (anything that is not vector) types from R to Rust and back. That involved stuff like traits, `impl` and `TryFrom` blocks. Luckily, this is not needed for data frames. At least not for how I want to use them here. `extendr-api` comes with a struct `Dataframe<T>` (a representation of a typed `data.frame`). A `data.frame` can be created from Rust with the trait `IntoDataFrameRow`. This trait can be derived for a single struct that represents a single row. The type of the row is then captured by the marker `T`. Now what does that mean?\n\nIn order to construct a `data.frame` row by row, we need to define a `struct` that tells Rust what a row of the final `data.frame` should look like.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncode <- r\"(\nuse extendr_api::prelude::*;\n\n#[derive(Debug,IntoDataFrameRow)]\nstruct Person {\n  first: String,\n  last: String,\n  age: i32\n}\n\n#[extendr]\nfn person2df(firstR: String, lastR: String, ageR: i32) -> Dataframe<Person> {\n  let v = vec![Person {first: firstR, last: lastR, age:ageR}];\n  let df = v.into_dataframe();\n  df.expect(\"Failed to return a data.frame\")\n}\n)\"\n\nrextendr::rust_source(\n  code = code\n)\n\ndf <- person2df(\"Alice\", \"Smith\", 31L)\nclass(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n\n```{.r .cell-code}\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  first  last age\n1 Alice Smith  31\n```\n\n\n:::\n:::\n\n\n\nNote that the type of the inport arguments is important! `firstR` and `lastR` need to be characters\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nperson2df(1, 2, 3)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in person2df(1, 2, 3): Expected Strings got Doubles\n```\n\n\n:::\n:::\n\n\n\n## Building a larger data frame\n\nThe function above is not very exciting. It can only return a one row data.frame and will never return more. What we need to do is to extend the function\nby allowing vector inputs. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncode <- r\"(\nuse extendr_api::prelude::*;\n\n#[derive(Debug, IntoDataFrameRow)]\nstruct Person {\n    first: String,\n    last: String,\n    age: i32,\n}\n\n#[extendr]\nfn people2df(firstR: Vec<String>, lastR: Vec<String>, ageR: Vec<i32>) -> Dataframe<Person> {\n\n    let people: Vec<Person> = firstR.into_iter()\n        .zip(lastR.into_iter())\n        .zip(ageR.into_iter())\n        .map(|((first, last), age)| Person { first, last, age })\n        .collect();\n\n    people.into_dataframe().expect(\"Failed to return a data.frame\")\n}\n)\"\n\nrextendr::rust_source(\n  code = code\n)\n```\n:::\n\n\n\nMaybe some clarifications are needed here. `zip()` is a method in Rust that combines two iterators into a single iterator of tuples. Each tuple contains elements from both iterators at the same index. In our case, it creates something like nested tuples. First it combines `firstR` and `lastR` and then adds `ageR`. The final tuples then look like this:\n\n```\n((\"Alice\", \"Smith\"), 25)\n((\"Bob\", \"Johnson\"), 30)\n((\"Charlie\", \"Brown\"), 22)\n```\n\nThe `map()` method converts each typle into a object of type Person by converting `((first, last), age)` into `Person { first, last, age }`. \n`collect()` then creates a `Vec<Person>` out of this. Now lets see if this works.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- people2df(\n  firstR = c(\"Alice\", \"Bob\", \"Charlie\"),\n  lastR = c(\"Smith\", \"Johnson\", \"Brown\"),\n  ageR = c(31L, 12L, 22L)\n)\n\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    first    last age\n1   Alice   Smith  31\n2     Bob Johnson  12\n3 Charlie   Brown  22\n```\n\n\n:::\n:::\n\n\n\nPerfect! Now we have a simple example of how to turn given R input into a data frame in Rust.\nThis approach is just a little limitting, because the our Rust data frame has a fixed setup: Three columns, two must be characters and one numeric.\nThis is good if we want to create a standard output. I used this approach in a small R package called [urlparser](https://github.com/schochastics/urlparser) (I will write a separate post on it.). The input is a vector of urls and the output a fixed data frame with nine columns, each containing a part of the parsed url. For other tasks we need some more flexibility.\n\n## Oh god there is `data_frame!`\n\nOk, so I was ready to move on to call it a day with this post when I learned about [`data_frame!`](https://docs.rs/extendr-api/latest/extendr_api/macro.data_frame.html). It is almost ridiculous how easy it is to create data frame from vectors with this.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncode <- r\"(\n    use extendr_api::prelude::*;\n    #[extendr]\n    fn people2df_short(firstR: Vec<String>, lastR: Vec<String>, ageR: Vec<i32>) -> List {\n      let res = data_frame!(\n        first = firstR,\n        last = lastR,\n        age = ageR\n      );\n      res.try_into().unwrap()\n    }\n)\"\n\nrextendr::rust_source(\n  code = code\n)\n```\n:::\n\n\n\nThis is so much easier and clearer comming from the perspective of an R programmer! \n\nHere is the function in action. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- people2df_short(\n  firstR = c(\"Alice\", \"Bob\", \"Charlie\"),\n  lastR = c(\"Smith\", \"Johnson\", \"Brown\"),\n  ageR = c(31L, 12L, 22L)\n)\n\nclass(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n\n```{.r .cell-code}\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    first    last age\n1   Alice   Smith  31\n2     Bob Johnson  12\n3 Charlie   Brown  22\n```\n\n\n:::\n:::\n\n\n\n**How does this work?** What we are using here is a \"Macro\". Macros are a powerful metaprogramming feature that allows code to be generated at compile time. While functions operate on values, macros operate on the syntax of the code itself. This enables more flexible and reusable patterns. If you want to learn more, check out [the book](https://doc.rust-lang.org/book/ch19-06-macros.html).\n\nLet us build a small illustrative example.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncode <- r\"(\n    use extendr_api::prelude::*;\n\n    macro_rules! sum_and_cheer {\n        ($a:expr, $b:expr) => {{\n            let sum = $a + $b;\n            rprint!(\"Rust rules!\");\n            sum\n        }};\n    }\n\n    #[extendr]\n    fn cheer_sum(a: f64, b: f64) -> f64 {\n        sum_and_cheer!(a, b)\n    }\n)\"\n\nrextendr::rust_source(\n  code = code\n)\n\ncheer_sum(1.1, 2.2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRust rules!\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.3\n```\n\n\n:::\n:::\n\n\n\nThe cool thing about Macros is that you can essentially hide away complex code and produce an easier to use API. That is pretty nice and does make working with Rust from R a lot easier!\n\n## Conclusion\n\nIn this post I did a little exploration on how to create data frames in Rust. \nI am super happy to have found the macro `data_frame!` which also helped me to understand what macros actually are.\nI am pretty sure I am still missing parts that would make working with data frames even simpler, but\nmy Rust journey has not ended yet.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}