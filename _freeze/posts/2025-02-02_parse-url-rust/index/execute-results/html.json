{
  "hash": "c27eb1ecd72ebf7d8ba85e88a3ebb795",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Fast url parsing in R with Rust\nauthor:\n- name: David Schoch\n  orcid: 0000-0003-2952-4812\ndate: '2025-02-02'\ncategories:\n- R\n- Rust\n- package\n---\n\n\n\nThis post is the conclusion (for now) of my second miniseries on Rust in R. My first series was about building two R packages without much context ([part1](https://blog.schochastics.net/posts/2024-02-23_parsing-phone-numbers-with-rust-and-r/index.html), [part2](https://blog.schochastics.net/posts/2024-02-27_chronos-fast-general-purpose-datetime-converter/index.html)) and the second about how to comunicate between Rust and R ([part1](https://blog.schochastics.net/posts/2025-01-29_rust-in-r-beyond-vectors/index.html), [part2](https://blog.schochastics.net/posts/2025-01-30_data-frames-in-rust/index.html)). In this post, I will introduce a small package, [urlparser](https://github.com/schochastics/urlparser) which wraps the [url](https://crates.io/crates/url) crate to parse urls.\n\n## Setting up the package\n\nThanks to `usethis` and `rextendr`, setting up a new package that uses Rust code is incredibly simple.\nYou can get a large chunk of the work done in three lines of R code.\n\n```r\nusethis::create_package(\"urlparser\")\nrextendr::use_extendr()\nrextendr::use_crate(\"url\", version = \"2.5.4\")\n```\n\nThis sets up everything you need and all that is left to do is write the Rust code in `/src/rust/src/lib.rs`.\nIn our case, we just need to wrap one single function `parse`. The function takes a url as a string and extracts the different parts of the url. These parts, we want to store in a data frame.\n\n```rust\n#[derive(Debug, IntoDataFrameRow)]\nstruct ParsedUrl {\n  url: String,\n  scheme: String,\n  host: String,\n  port: String,\n  path: String,\n  query: String,\n  fragment: String,\n  username: String,\n  password: String,\n}\n\n#[extendr]\nfn url_parse(urls: Vec<String>) -> Dataframe<ParsedUrl> {\n  urls.into_iter()\n    .map(|url| {\n      let parsed_url = Url::parse(&url);\n      let (scheme, host, port, path, query, fragment, username, password) =\n        parsed_url.as_ref().ok().map_or_else(\n          || Default::default(),\n          |p| (\n            p.scheme().to_string(),\n            p.host_str().unwrap_or(\"\").to_string(),\n            p.port().map_or_else(String::new, |p| p.to_string()),\n            p.path().to_string(),\n            p.query().unwrap_or(\"\").to_string(),\n            p.fragment().unwrap_or(\"\").to_string(),\n            p.username().to_string(),\n            p.password().unwrap_or(\"\").to_string(),\n          ),\n        );\n\n        ParsedUrl {\n            url,\n            scheme,\n            host,\n            port,\n            path,\n            query,\n            fragment,\n            username,\n            password,\n        }\n        })\n        .collect::<Vec<_>>() \n        .into_dataframe() \n        .unwrap()\n}\n```\n\nIf you have followed the last two posts, you should understand what is going on here, although it is a bit more complex. `struct ParsedUrl` defines what a row in our final data frame should look like and `fn url_parse()` uses `Url::parse` to extract the different parts of the url. On the R side of the package I just added a small wrapper around it\n\n```r\nrs_url_parse <- function(url){\n  url_parse(url)\n}\n```\n\nAnd just like that, we are done. What remains is to check how the package compares to existing solutions.\n\n## Benchmark\n\nWe compare the performance of the package with [adaR](https://github.com/gesistsa/adaR), an R package to parse URLs that wraps the C++ library [ada-url](https://github.com/ada-url/ada). I have also blogged about the creation of that package ([link](https://github.com/ada-url/ada)). \n\nLet us look at an example what both packages return.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nurlparser::rs_url_parse(\n  \"https://user_1:password_1@example.org:8080/dir/../api?q=1#frag\"\n) |>\n  str()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t1 obs. of  9 variables:\n $ url     : chr \"https://user_1:password_1@example.org:8080/dir/../api?q=1#frag\"\n $ scheme  : chr \"https\"\n $ host    : chr \"example.org\"\n $ port    : chr \"8080\"\n $ path    : chr \"/api\"\n $ query   : chr \"q=1\"\n $ fragment: chr \"frag\"\n $ username: chr \"user_1\"\n $ password: chr \"password_1\"\n```\n\n\n:::\n\n```{.r .cell-code}\nadaR::ada_url_parse(\n  \"https://user_1:password_1@example.org:8080/dir/../api?q=1#frag\"\n) |>\n  str()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t1 obs. of  10 variables:\n $ href    : chr \"https://user_1:password_1@example.org:8080/api?q=1#frag\"\n $ protocol: chr \"https:\"\n $ username: chr \"user_1\"\n $ password: chr \"password_1\"\n $ host    : chr \"example.org:8080\"\n $ hostname: chr \"example.org\"\n $ port    : chr \"8080\"\n $ pathname: chr \"/api\"\n $ search  : chr \"?q=1\"\n $ hash    : chr \"#frag\"\n```\n\n\n:::\n:::\n\n\n\nThe naming scheme is a bit different, but they essentially return the exact same result.\n\nI will skip correctness benchmarks here and skip right to the runtime, because that is what interested me the most.\nWe take a list of diverse urls provided from [ada-url](https://github.com/ada-url/url-various-datasets) for this purpose\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop100 <- readLines(\n  \"https://raw.githubusercontent.com/ada-url/url-various-datasets/main/top100/top100.txt\"\n)\ntop100[1:20]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"https://www.google.com/imghp?hl=en&tab=wi\"                                                                                       \n [2] \"https://maps.google.com/maps?hl=en&tab=wl\"                                                                                       \n [3] \"https://play.google.com/?hl=en&tab=w8\"                                                                                           \n [4] \"https://www.youtube.com/?tab=w1\"                                                                                                 \n [5] \"https://news.google.com/?tab=wn\"                                                                                                 \n [6] \"https://mail.google.com/mail/?tab=wm\"                                                                                            \n [7] \"https://drive.google.com/?tab=wo\"                                                                                                \n [8] \"https://www.google.com/intl/en/about/products?tab=wh\"                                                                            \n [9] \"http://www.google.com/history/optout?hl=en\"                                                                                      \n[10] \"https://accounts.google.com/ServiceLogin?hl=en&passive=true&continue=https://www.google.com/&ec=GAZAAQ\"                          \n[11] \"https://www.google.com/webhp?tab=iw\"                                                                                             \n[12] \"https://maps.google.com/maps?hl=en&tab=il\"                                                                                       \n[13] \"https://play.google.com/?hl=en&tab=i8\"                                                                                           \n[14] \"https://www.youtube.com/?tab=i1\"                                                                                                 \n[15] \"https://news.google.com/?tab=in\"                                                                                                 \n[16] \"https://mail.google.com/mail/?tab=im\"                                                                                            \n[17] \"https://drive.google.com/?tab=io\"                                                                                                \n[18] \"https://www.google.com/intl/en/about/products?tab=ih\"                                                                            \n[19] \"https://accounts.google.com/ServiceLogin?hl=en&passive=true&continue=https://www.google.com/imghp%3Fhl%3Den%26tab%3Dwi&ec=GAZAAg\"\n[20] \"https://support.google.com/accounts?p=signin_privatebrowsing&hl=en\"                                                              \n```\n\n\n:::\n\n```{.r .cell-code}\nlength(top100)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 100031\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(\n  check = FALSE,\n  adaR = adaR::ada_url_parse(top100),\n  rust = urlparser::rs_url_parse(top100)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 Ã— 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 adaR          317ms    324ms      3.09    47.4MB     3.09\n2 rust          126ms    128ms      7.78    8.28MB     0   \n```\n\n\n:::\n:::\n\n\n\nOur simple package outperforms adaR with a factor of 2. That is wild to me, given how much time we spent on optimizing the interface between R and C++ to create as little overhead as possible. Here, we did not do any real optimization efforts, so the performance boost can probably be attributed to Rust alone.\n\nIt might seem flashy but you should still take these results with a grain of salt. While `adaR` is also relatively new, I'd still say that it is far more robust than the package we built here. No testing beyond eyeballing has been done so far. Maybe jsut take the result as a proof of concept on how quickly one can spin up a solution in Rust that could speed up your own workflows, without spending too much time in optimizing the code/interface.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}